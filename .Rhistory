# candidates of the current election, if it there's a match, 1 will be assigned to
# the StandAgain variable. If there is no match, 0 is assigned.
if(any(pmatch(MayorElection$NameCandidate1[i-1], allCandidates), na.rm = TRUE)) {
MayorElection$StandAgain[i] <- 1
} else {
MayorElection$StandAgain[i] <- 0
}
}
table(MayorElection$StandAgain)
table(MayorElection$StandAgain, useNA = "always")
# R code for the cleaning of the data, creation of additional variables, subsetting and lagging of variables
# Author: Malte Berneaud
# Date: 30.04.2016
# Packages needed for the execution of this Rmd are listed in include.packages and checked against the installed packages on the machine executing the code. If they are not installed, they will be installed automatically.
include.packages <- c("dplyr", "ggplot2", "stringr", "readxl", "DataCombine", "texreg",
"stargazer", "MASS")
needed.packages <- include.packages[!(include.packages %in% installed.packages()[, "Package"])]
if(length(needed.packages)) install.packages(needed.packages,
repos = "https://cran.uni-muenster.de/")
lapply(include.packages, library, character.only = TRUE)  # loading all packages at once
# Loading data ------------------------------------------------------------
# Sparkassen Board Membership data
SparkassenBoard <- read_excel("data/BankBoards_Bavaria_RImport.xlsx",
sheet = "BoardComp")
## define variable class:
SparkassenBoard$Incumbent <- as.character(SparkassenBoard$Incumbent)
# Municipal Election data
MayorElection <- read_excel("data/MayorElectionData.xlsx",
sheet = "Bgm_OB")
# Cleaning Sparkassen data set --------------------------------------------
# renaming variables
oldnames <- c("^name$", "^political...employee$", "^governing...opposition$", "retired.1.yes.",
"Name_CountyMunicipality", "Type_CountyMunicipality")
newnames <- c("NameCandidate1", "political_employee", "governing_opposition", "retired",
"NameMunicipality", "type_county_municipality")
for (i in seq_along(oldnames)) {
names(SparkassenBoard) <- gsub(oldnames[i], newnames[i], names(SparkassenBoard))
}
# trimming whitespace:
SparkassenBoard$NameMunicipality <- str_trim(SparkassenBoard$NameMunicipality)
SparkassenBoard$NameCandidate1 <- str_trim(SparkassenBoard$NameCandidate1)
# creating variable for top position
SparkassenBoard$TopPosition <- 0
SparkassenBoard$TopPosition[SparkassenBoard$chair != "no"] <- 1
SparkassenBoard$TopPosition <- as.character(SparkassenBoard$TopPosition)
# Create sub-dataframes
## :unique banks
SparkassenBoard_UniqueBanks <- unique(SparkassenBoard[ ,c("bank_ID", "bank_name",
"federal_state", "city",
"board_size")])
## :Top Positions only
SparkassenBoard_TopPositions <- subset(SparkassenBoard, TopPosition == 1)
# Cleaning municipality election data set ---------------------------------
# removing newlines
names(MayorElection) <- str_replace_all(names(MayorElection), "[\r\n]" , "")
# removing punctuation
names(MayorElection) <- gsub("[[:punct:]]", "", names(MayorElection))
# removing whitespace
names(MayorElection) <- str_trim(names(MayorElection))
# correcting "Geschlecht"
names(MayorElection) <- gsub("^Geschl", "Geschlecht", names(MayorElection))
# Changing label names
newnames <- c("IDMunicipality","NameMunicipality", "ElectionDate", "RunOffNecessary", "ElectionType", "ProfPolitician", "NumberEligVoter", "NumberVoters", "InvalBallots", "ValBallots", "NameCandidate1")
names(MayorElection)[1:11] <- newnames
names(MayorElection) <- gsub("gültigeStimmen 1", "VotesCandidate1", names(MayorElection))
names(MayorElection) <- gsub("Stimmen für nicht genannte Bewerber zusammen", "VotesRest", names(MayorElection))
# removing empty column 85
MayorElection[, 85] <- NULL
# Cleaning of gender strings
MayorElection$Geschlecht1 <- str_trim(MayorElection$Geschlecht1)
# cleaning of party names
MayorElection$MayorParty <- MayorElection$"Wahlvorschlag 1"
MayorElection$MayorParty <- str_trim(MayorElection$MayorParty)
# reduce party to main party only
MayorElection$MayorParty <- sub("/.*","", MayorElection$MayorParty)
# Cleaning the party names for bar plotting
MayorElection$CleanParty <- NA
for(i in 1:nrow(MayorElection)) {
if(is.na(MayorElection$MayorParty[i])) {
next
}
if(grepl("CSU", MayorElection$MayorParty[i])) {
MayorElection$CleanParty[i] <- "CSU"
}else if(grepl("SPD", MayorElection$MayorParty[i])) {
MayorElection$CleanParty[i] <- "SPD"
} else {
MayorElection$CleanParty[i] <- "Other"
}
}
# Creating additional variables -------------------------------------------
# Extracting Phd titles
MayorElection$Phd <- NA
MayorElection$Phd <- ifelse(grepl("Dr.", MayorElection$NameCandidate1), 1, 0)
MayorElection$NameCandidate1 <- gsub(" Dr.", "", MayorElection$NameCandidate1)
MayorElection$NameCandidate1 <- gsub(" jur.", "", MayorElection$NameCandidate1)
# creating the total number of terms for each mayor
tally <- dplyr::tally(group_by(MayorElection, NameCandidate1))
names(tally)[2] <- "TotalTerms"
#merging that back into the data frame
MayorElection <- merge(MayorElection, tally)
# Extracting years from the election date character string
MayorElection$Year <- strtrim(MayorElection$ElectionDate, 4L)
MayorElection$Year <- as.integer(MayorElection$Year)  ## coercing year variable to an integer
# Dummy variable for contested elections
MayorElection$Contested <- ifelse(nchar(MayorElection$`Name 2Nachname Titel Vorname`)>2, 1, 0)
# Calculating votes shares from the data
MayorElection$VoteShareWinner <-  (MayorElection$VotesCandidate1 / MayorElection$ValBallots) * 100
# Merging data sets -------------------------------------------------------
# Ordering the data by municipality
MayorElection$IDMunicipality <- as.integer(MayorElection$IDMunicipality)
MayorElection <- arrange(MayorElection, IDMunicipality, Year)
##: variable for board membership
MayorElection$SparkassenMember <- is.element(MayorElection$NameCandidate1, unique(SparkassenBoard$NameCandidate1))
##: variable for board membership of incumbent
#library(DataCombine) # I moved the loading of the library up in the initiatl code which checks whether all necessary packages are installed, installs missings and then load them (named: "fetching_library") (MB)
MayorElection <- slide(MayorElection, Var = "SparkassenMember",
NewVar = "IncumbentSparkassenMember")
# Subsetting the data set (part 1) -------------------------------------------------
# subsetting by election type; excluding run-off elections
MayorElection <- subset(MayorElection, ElectionType != 3)
# Subsetting to contested elections only
MayorElection <- subset(MayorElection, Contested == 1)
# creating a vector with the column numbers of all other candidate names
otherCandidateColumns <- grep("Name ", names(MayorElection))
for(i in otherCandidateColumns) {
MayorElection[, i]<- gsub(" Dr.", "", MayorElection[, i])
MayorElection[, i]<- gsub(" jur.", "", MayorElection[, i])
}
MayorElection <- slide(MayorElection, Var = "NameCandidate1",
GroupVar = "IDMunicipality",
NewVar = "L.NameCandidate1")
MayorElection$Retired <- 1
MayorElection$Retired[MayorElection$NameCandidate1 ==
MayorElection$L.NameCandidate1] <- 0
MayorElection$Retired[MayorElection$`Name 2Nachname Titel Vorname` ==
MayorElection$L.NameCandidate1] <- 0
MayorElection$Retired[MayorElection$`Name 3Nachname Titel Vorname` ==
MayorElection$L.NameCandidate1] <- 0
MayorElection$Retired[MayorElection$`Name 4Nachname Titel Vorname` ==
MayorElection$L.NameCandidate1] <- 0
tanble(MayorElection$Retired)
table(MayorElection$Retired)
source('~/Git/FinalProject/paper/standalone_R_code.R')
# R code for the cleaning of the data, creation of additional variables, subsetting and lagging of variables
# Author: Malte Berneaud
# Date: 30.04.2016
# Packages needed for the execution of this Rmd are listed in include.packages and checked against the installed packages on the machine executing the code. If they are not installed, they will be installed automatically.
include.packages <- c("dplyr", "ggplot2", "stringr", "readxl", "DataCombine", "texreg",
"stargazer", "MASS")
needed.packages <- include.packages[!(include.packages %in% installed.packages()[, "Package"])]
if(length(needed.packages)) install.packages(needed.packages,
repos = "https://cran.uni-muenster.de/")
lapply(include.packages, library, character.only = TRUE)  # loading all packages at once
# Loading data ------------------------------------------------------------
# Sparkassen Board Membership data
SparkassenBoard <- read_excel("data/BankBoards_Bavaria_RImport.xlsx",
sheet = "BoardComp")
## define variable class:
SparkassenBoard$Incumbent <- as.character(SparkassenBoard$Incumbent)
# Municipal Election data
MayorElection <- read_excel("data/MayorElectionData.xlsx",
sheet = "Bgm_OB")
# Cleaning Sparkassen data set --------------------------------------------
# renaming variables
oldnames <- c("^name$", "^political...employee$", "^governing...opposition$", "retired.1.yes.",
"Name_CountyMunicipality", "Type_CountyMunicipality")
newnames <- c("NameCandidate1", "political_employee", "governing_opposition", "retired",
"NameMunicipality", "type_county_municipality")
for (i in seq_along(oldnames)) {
names(SparkassenBoard) <- gsub(oldnames[i], newnames[i], names(SparkassenBoard))
}
# trimming whitespace:
SparkassenBoard$NameMunicipality <- str_trim(SparkassenBoard$NameMunicipality)
SparkassenBoard$NameCandidate1 <- str_trim(SparkassenBoard$NameCandidate1)
# creating variable for top position
SparkassenBoard$TopPosition <- 0
SparkassenBoard$TopPosition[SparkassenBoard$chair != "no"] <- 1
SparkassenBoard$TopPosition <- as.character(SparkassenBoard$TopPosition)
# Create sub-dataframes
## :unique banks
SparkassenBoard_UniqueBanks <- unique(SparkassenBoard[ ,c("bank_ID", "bank_name",
"federal_state", "city",
"board_size")])
## :Top Positions only
SparkassenBoard_TopPositions <- subset(SparkassenBoard, TopPosition == 1)
# Cleaning municipality election data set ---------------------------------
# removing newlines
names(MayorElection) <- str_replace_all(names(MayorElection), "[\r\n]" , "")
# removing punctuation
names(MayorElection) <- gsub("[[:punct:]]", "", names(MayorElection))
# removing whitespace
names(MayorElection) <- str_trim(names(MayorElection))
# correcting "Geschlecht"
names(MayorElection) <- gsub("^Geschl", "Geschlecht", names(MayorElection))
# Changing label names
newnames <- c("IDMunicipality","NameMunicipality", "ElectionDate", "RunOffNecessary", "ElectionType", "ProfPolitician", "NumberEligVoter", "NumberVoters", "InvalBallots", "ValBallots", "NameCandidate1")
names(MayorElection)[1:11] <- newnames
names(MayorElection) <- gsub("gültigeStimmen 1", "VotesCandidate1", names(MayorElection))
names(MayorElection) <- gsub("Stimmen für nicht genannte Bewerber zusammen", "VotesRest", names(MayorElection))
# removing empty column 85
MayorElection[, 85] <- NULL
# Cleaning of gender strings
MayorElection$Geschlecht1 <- str_trim(MayorElection$Geschlecht1)
# cleaning of party names
MayorElection$MayorParty <- MayorElection$"Wahlvorschlag 1"
MayorElection$MayorParty <- str_trim(MayorElection$MayorParty)
# reduce party to main party only
MayorElection$MayorParty <- sub("/.*","", MayorElection$MayorParty)
# Cleaning the party names for bar plotting
MayorElection$CleanParty <- NA
for(i in 1:nrow(MayorElection)) {
if(is.na(MayorElection$MayorParty[i])) {
next
}
if(grepl("CSU", MayorElection$MayorParty[i])) {
MayorElection$CleanParty[i] <- "CSU"
}else if(grepl("SPD", MayorElection$MayorParty[i])) {
MayorElection$CleanParty[i] <- "SPD"
} else {
MayorElection$CleanParty[i] <- "Other"
}
}
# Creating additional variables -------------------------------------------
# Extracting Phd titles
MayorElection$Phd <- NA
MayorElection$Phd <- ifelse(grepl("Dr.", MayorElection$NameCandidate1), 1, 0)
MayorElection$NameCandidate1 <- gsub(" Dr.", "", MayorElection$NameCandidate1)
MayorElection$NameCandidate1 <- gsub(" jur.", "", MayorElection$NameCandidate1)
# creating the total number of terms for each mayor
tally <- dplyr::tally(group_by(MayorElection, NameCandidate1))
names(tally)[2] <- "TotalTerms"
#merging that back into the data frame
MayorElection <- merge(MayorElection, tally)
# Extracting years from the election date character string
MayorElection$Year <- strtrim(MayorElection$ElectionDate, 4L)
MayorElection$Year <- as.integer(MayorElection$Year)  ## coercing year variable to an integer
# Dummy variable for contested elections
MayorElection$Contested <- ifelse(nchar(MayorElection$`Name 2Nachname Titel Vorname`)>2, 1, 0)
# Calculating votes shares from the data
MayorElection$VoteShareWinner <-  (MayorElection$VotesCandidate1 / MayorElection$ValBallots) * 100
# Merging data sets -------------------------------------------------------
# Ordering the data by municipality
MayorElection$IDMunicipality <- as.integer(MayorElection$IDMunicipality)
MayorElection <- arrange(MayorElection, IDMunicipality, Year)
##: variable for board membership
MayorElection$SparkassenMember <- is.element(MayorElection$NameCandidate1, unique(SparkassenBoard$NameCandidate1))
##: variable for board membership of incumbent
#library(DataCombine) # I moved the loading of the library up in the initiatl code which checks whether all necessary packages are installed, installs missings and then load them (named: "fetching_library") (MB)
MayorElection <- slide(MayorElection, Var = "SparkassenMember",
NewVar = "IncumbentSparkassenMember")
# Subsetting the data set (part 1) -------------------------------------------------
# subsetting by election type; excluding run-off elections
MayorElection <- subset(MayorElection, ElectionType != 3)
# Subsetting to contested elections only
MayorElection <- subset(MayorElection, Contested == 1)
# creating dummy for retired mayors ---------------------------------------
# creating a vector with the column numbers of all other candidate names
otherCandidateColumns <- grep("Name ", names(MayorElection))
# cleaning the remaining candidate columns from " Dr." and " jur." strings
for(i in otherCandidateColumns) {
MayorElection[, i]<- gsub(" Dr.", "", MayorElection[, i])
MayorElection[, i]<- gsub(" jur.", "", MayorElection[, i])
}
# # excluding mayors who did not run again (likely because of retirement) (MBK)
# # creating empty variable to be filled in next step
# MayorElection$StandAgain <- NA
# # Loop starts at 2nd observation because otherwise 0 would be returned for i-1,
# # which results in NA for the logical condition of the if structure
# for(i in 2:nrow(MayorElection)) {
#   # Creating a vector with the names of all candidates which ran in it
#   allCandidates <- as.character(MayorElection[i, c(1, otherCandidateColumns)])
# # Partially matching the name of the previous mayor among the names of all
# # candidates of the current election, if it there's a match, 1 will be assigned to
# # the StandAgain variable. If there is no match, 0 is assigned.
#   if(any(pmatch(MayorElection$NameCandidate1[i-1], allCandidates), na.rm = TRUE)) {
#     MayorElection$StandAgain[i] <- 1
#   } else {
#     MayorElection$StandAgain[i] <- 0
#   }
# }
# MayorElection2 <- plyr::ddply(MayorElection, IDMunicipality, function(x) {
#   data.frame(
#     IDMunicipality = IDMunicipality,
#     ElectionDate = ElectionDate,
#     StandAgain = ifelse()
#   )
# })
# Excluding mayors who probably retired (JM)
MayorElection <- slide(MayorElection, Var = "NameCandidate1",
GroupVar = "IDMunicipality",
NewVar = "L.NameCandidate1")
MayorElection$Retired <- 1
MayorElection$Retired[MayorElection$NameCandidate1 ==
MayorElection$L.NameCandidate1] <- 0
MayorElection$Retired[MayorElection$`Name 2Nachname Titel Vorname` ==
MayorElection$L.NameCandidate1] <- 0
MayorElection$Retired[MayorElection$`Name 3Nachname Titel Vorname` ==
MayorElection$L.NameCandidate1] <- 0
MayorElection$Retired[MayorElection$`Name 4Nachname Titel Vorname` ==
MayorElection$L.NameCandidate1] <- 0
# creating lagged variables -----------------------------------------------
## Lagged DV
# creating lagged incumbency for the calculation of the re-election binary variable
# MayorElection <- slide(MayorElection, Var = "NameCandidate1", TimeVar = "ElectionDate", NewVar = "L.NameCandidate1")
MayorElection$Reelection <- ifelse(MayorElection$NameCandidate1 == MayorElection$L.NameCandidate1, 1, 0)
# Lagging variables for analysis, lag of SparkassenMembership is already implemented above. Lag variable is called "IncumbentSparkassenMember"
MayorElection <- slide(MayorElection, Var = "Geschlecht1", TimeVar = "ElectionDate", NewVar = "L.Geschlecht1")
MayorElection <- slide(MayorElection, Var = "VoteShareWinner", TimeVar = "ElectionDate", NewVar = "L.VoteShareWinner")
# excluding mayors who did not run again (likely because of retirement) (MBK)
# creating empty variable to be filled in next step
MayorElection$StandAgain <- NA
# Loop starts at 2nd observation because otherwise 0 would be returned for i-1,
# which results in NA for the logical condition of the if structure
for(i in 2:nrow(MayorElection)) {
# Creating a vector with the names of all candidates which ran in it
allCandidates <- as.character(MayorElection[i, c(1, otherCandidateColumns)])
# Partially matching the name of the previous mayor among the names of all
# candidates of the current election, if it there's a match, 1 will be assigned to
# the StandAgain variable. If there is no match, 0 is assigned.
if(any(pmatch(MayorElection$L.NameCandidate1, allCandidates), na.rm = TRUE)) {
MayorElection$StandAgain[i] <- 1
} else {
MayorElection$StandAgain[i] <- 0
}
}
?slide
table(MayorElection$Retired)
table(MayorElection$StandAgain)
MayorElection$L.NameCandidate1
# excluding mayors who did not run again (likely because of retirement) (MBK)
# creating empty variable to be filled in next step
MayorElection$StandAgain <- NA
# Loop starts at 2nd observation because otherwise 0 would be returned for i-1,
# which results in NA for the logical condition of the if structure
for(i in 2:nrow(MayorElection)) {
# Creating a vector with the names of all candidates which ran in it
allCandidates <- as.character(MayorElection[i, c(1, otherCandidateColumns)])
# Partially matching the name of the previous mayor among the names of all
# candidates of the current election, if it there's a match, 1 will be assigned to
# the StandAgain variable. If there is no match, 0 is assigned.
if(any(pmatch(MayorElection$L.NameCandidate1[i], allCandidates), na.rm = TRUE)) {
MayorElection$StandAgain[i] <- 1
} else {
MayorElection$StandAgain[i] <- 0
}
}
table(MayorElection$StandAgain)
table(MayorElection$Retired
)
allCandidates <- as.character(MayorElection[1, c(1, otherCandidateColumns)])
allCandidates
pmatch(NA, allCandidates)
MayorElection$StandAgain <- NA
for(i in 2:nrow(MayorElection)) {
# Creating a vector with the names of all candidates which ran in it
allCandidates <- as.character(MayorElection[i, c(1, otherCandidateColumns)])
# Partially matching the name of the previous mayor among the names of all
# candidates of the current election, if it there's a match, 1 will be assigned to
# the StandAgain variable. If there is no match, 0 is assigned.
if(is.na(MayorElection$L.NameCandidate1)) {
next()
}
if(any(pmatch(MayorElection$L.NameCandidate1[i], allCandidates), na.rm = TRUE)) {
MayorElection$StandAgain[i] <- 1
} else {
MayorElection$StandAgain[i] <- 0
}
}
warnings()
MayorElection$StandAgain <- NA
# Loop starts at 2nd observation because otherwise 0 would be returned for i-1,
# which results in NA for the logical condition of the if structure
for(i in 2:nrow(MayorElection)) {
# Creating a vector with the names of all candidates which ran in it
allCandidates <- as.character(MayorElection[i, c(1, otherCandidateColumns)])
# Partially matching the name of the previous mayor among the names of all
# candidates of the current election, if it there's a match, 1 will be assigned to
# the StandAgain variable. If there is no match, 0 is assigned.
if(is.na(MayorElection$L.NameCandidate1[i])) {
next()
}
if(any(pmatch(MayorElection$L.NameCandidate1[i], allCandidates), na.rm = TRUE)) {
MayorElection$StandAgain[i] <- 1
} else {
MayorElection$StandAgain[i] <- 0
}
}
table(MayorElection$StandAgain, useNA = "always")
table(MayorElection$L.NameCandidate1, useNA = "always")
table(MayorElection$StandAgain, useNA = "always")
# creating empty variable to be filled in next step
MayorElection$StandAgain <- NA
# Loop starts at 2nd observation because otherwise 0 would be returned for i-1,
# which results in NA for the logical condition of the if structure
for(i in 2:nrow(MayorElection)) {
# Creating a vector with the names of all candidates which ran in it
allCandidates <- as.character(MayorElection[i, c(1, otherCandidateColumns)])
# Partially matching the name of the previous mayor among the names of all
# candidates of the current election, if it there's a match, 1 will be assigned to
# the StandAgain variable. If there is no match, 0 is assigned.
if(is.na(MayorElection$L.NameCandidate1[i])) {
next()
}
if(any(pmatch(MayorElection$L.NameCandidate1[i], allCandidates), na.rm = TRUE)) {
MayorElection$StandAgain[i] <- 1
} else {
MayorElection$StandAgain[i] <- 0
}
}
MayorElection <- subset(MayorElection, StandAgain == 1)
MayorElection$Reelection <- ifelse(MayorElection$NameCandidate1 == MayorElection$L.NameCandidate1, 1, 0)
# Lagging variables for analysis, lag of SparkassenMembership is already implemented above. Lag variable is called "IncumbentSparkassenMember"
MayorElection <- slide(MayorElection, Var = "Geschlecht1", TimeVar = "ElectionDate", NewVar = "L.Geschlecht1")
MayorElection <- slide(MayorElection, Var = "VoteShareWinner", TimeVar = "ElectionDate", NewVar = "L.VoteShareWinner")
# Subsetting for years ----------------------------------------------------
MayorElection <- subset(MayorElection, Year >= 2006)
fullmodel <- glm(Reelection~IncumbentSparkassenMember + L.VoteShareWinner + L.Geschlecht1 + log(NumberEligVoter),
data = MayorElection,
family = "binomial")
covarnames <- c("Sparkassen board member", "Previous vote share", "Female", "Number eligible voters")
summary(fullmodel)
source('~/Git/FinalProject/paper/standalone_R_code.R')
source('~/Git/FinalProject/paper/standalone_R_code.R')
fullmodel <- glm(Reelection~IncumbentSparkassenMember + L.VoteShareWinner + L.Geschlecht1 + log(NumberEligVoter),
data = MayorElection,
family = "binomial")
covarnames <- c("Sparkassen board member", "Previous vote share", "Female", "Number eligible voters")
summary(fullmodel)
stargazer(fullmodel, title = "Logistic regression results w/ odds ratios", dep.var.labels = "Re-election of mayor",
covariate.labels = covarnames, header = FALSE, font.size = "scriptsize", single.row = TRUE,
apply.coef = exp, t.auto = F, p.auto = F, report = "vcp*", digits = 2, keep.stat = c("n", "ll", "rsq"))
source("paper/standalone_R_code.R")
source('~/Git/FinalProject/paper/standalone_R_code.R')
setwd("paper/")
getwd()
source('~/Git/FinalProject/paper/standalone_R_code.R')
d <- density(MayorElection$VoteShareWinner , na.rm = TRUE)
plot(d, main = "Kernel density: Vote shares of Winners", xlab = "Eligible Voters Per Municipality")
source('~/.active-rstudio-document', echo=TRUE)
d <- density(MayorElection$L.VoteShareWinner , na.rm = TRUE)
plot(d, main = "Kernel density: Vote shares of winning mayor in previous election", xlab = "Vote share of Winners")
reelections <- group_by(MayorElection, CleanParty)
library(dplyr)
reelections <- group_by(MayorElection, CleanParty)
reelections$Reelection <- as.character(reelections$Reelection) %>%  as.integer(.)
reelections <- summarise(reelections, total.mayors.party = n(),
number.reelected.mayors = sum(Reelection, na.rm = TRUE))
reelections <- mutate(reelections, share.reelections = number.reelected.mayors / total.mayors.party)
table(reelections$share.reelections)
reelections <- mutate(reelections, share.reelections = number.reelected.mayors / total.mayors.party) %>% tbl_df()
```
reelections <- mutate(reelections, share.reelections = number.reelected.mayors / total.mayors.party) %>% tbl_df()
```
reelections <- mutate(reelections, share.reelections = number.reelected.mayors / total.mayors.party)
View(reelections)
reelections <- tbl_df(reelections)
reelections
table(MayorElection$CleanParty)
party_affiliations<- table(MayorElection$CleanParty)
prop.table(party_affiliations, 2)
party_affiliations<- table(MayorElection$CleanParty)
prop.table(party_affiliations, 2)
party_affiliations<- table(MayorElection$Reelection, MayorElection$CleanParty)
prop.table(party_affiliations, 2)
frequency(MayorElection$CleanParty)
table(MayorElection$CleanParty)
prop.table(table(MayorElection$CleanParty))
tbl <- table(MayorElection$CleanParty)
cbind(tbl, prop.table(tbl))
source('~/Git/FinalProject/paper/standalone_R_code.R')
source('~/Git/FinalProject/paper/standalone_R_code.R')
source('~/.active-rstudio-document', echo=TRUE)
source('~/Git/FinalProject/paper/standalone_R_code.R')
setwd(paper)
setwd("paper/")
source('~/Git/FinalProject/paper/standalone_R_code.R')
table(MayorElection2$Reelection)
prop.table(table(MayorElection2$Reelection))
installed.packages("xtable")
install.packages("xtable")
library(xtable)
tbl <- table(MayorElection2$SparkassenMember, MayorElection2$Reelection)
tbl
tbl2 <- prop.table(tbl, 2)
tbl2
tbl2 <- prop.table(tbl, 1)
tbl2
tbl3 <- cbind(tbl, tbl2)
tbl3
df <- data.frame(freq.unelected = tbl3[, 1], freq.reelected = tbl3[, 2],
percentage.unelected = tbl3[, 3], percentage.reelected = tbl3[, 4])
View(df)
df <- data.frame(freq.unelected = tbl3[, 1], freq.reelected = tbl3[, 2],
percentage.unelected = tbl3[, 3], percentage.reelected = tbl3[, 4],
row.names = c("non_board_members", "board_members"))
View(df)
xt <- xtable(df)
print.xtable(xt)
tbl <- table(MayorElection2$SparkassenMember, MayorElection2$Reelection)
tbl2 <- prop.table(tbl, 1)
tbl3 <- cbind(tbl, tbl2)
df <- data.frame("Number not reelected mayors" = tbl3[, 1], "Number of reelected mayors" = tbl3[, 2],
percentage.unelected = tbl3[, 3], percentage.reelected = tbl3[, 4],
row.names = c("not Sparkassen board members, "Sparkassen board members"))
df <- data.frame("Number not reelected mayors" = tbl3[, 1], "Number of reelected mayors" = tbl3[, 2],
percentage.unelected = tbl3[, 3], percentage.reelected = tbl3[, 4],
row.names = c("not Sparkassen board members", "Sparkassen board members"))
xt <- xtable(df)
print.xtable(xt)
source('~/.active-rstudio-document', echo=TRUE)
warning()
warnings()
